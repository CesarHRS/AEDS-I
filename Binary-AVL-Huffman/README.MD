# README: Trabalho Pr√°tico 1

# OBJETIVOS

<div align="justify">

<p>Foi proposto pelo Prof. Me. <b>Michel Pires da Silva</b> na disciplina de <b>Algoritmos e Estrutura de Dados II</b>, 
um trabalho no qual o objetivo era <b>criar um <i>heap</i> contendo os </b><i>'K'</i><b> elementos que mais se repetiam 
durante os textos de entrada inserido pelo usu√°rio. Tirando as palavras inseridas no arquivo input.txt </b></p>

<p>Sendo assim, ap√≥s a conclus√£o do projeto, temos aqui um algor√≠tmo capaz de:

<b>- [‚úîÔ∏è] Ler cada palavra dentro do arquivo input.txt;<br></b>
<b>- [‚úîÔ∏è] Ler cada arquivo de texto;<br></b>
<b>- [‚úîÔ∏è] Construir uma tabela hash com os 'n' termos que aparecerem em cada arquivo de texto, sem conter as palavras do
arquivo input.txt e removendo as stopwords;<br></b>
<b>- [‚úîÔ∏è] Construir uma heap com os 'K' elementos que mais aparecem na tabela hash;<br></b>
<b>- [‚úîÔ∏è] Criar uma √°rvore bin√°ria com essa heap;</br></b>
<b>- [‚úîÔ∏è] Imprimir esta arvore pelo m√©todo Inorder;</br></b>
<b>- [‚úîÔ∏è] Criar uma √°rvore AVL com a mesma heap;</br></b>
<b>- [‚úîÔ∏è] Imprimir esta √°rvore pelo m√©todo Inorder;</br></b>
<b>- [‚úîÔ∏è] Criar uma √°rvore Huffman com a mesma heap;</br></b>
<b>- [‚úîÔ∏è] Imprimir esta √°rvore pelo m√©todo Inorder;</br></b>
<b>- [‚úîÔ∏è] Mostrar o tempo necess√°rio para inserir e imprimir cada uma das √°rvores em cada itera√ß√£o do loop;</br></b>
</p>

<p>Vale informar aos que n√£o conhecem, que as estruturas: <i>unordered_Map</i>, <i>vector</i> e <i>map</i> s√£o pr√≥prias 
da linguagem C++, portanto, caso haja alguma d√∫vida quanto ao seu funcionamento, no site <i>CPlusPlus</i> √© poss√≠vel 
encontrar todas informa√ß√µes sobre estrutura, contexto, implementa√ß√£o e fun√ß√µes associadas de ambos. Tamb√©m √© v√°lido 
introduzir o termo "<i>stopwords"</i> que nada mais s√£o que palavras que devem ser desconsideradas durante a an√°lise
do texto, pois impactariam diretamente no resultado durante a contagem de repeti√ß√µes. Estas, s√£o palavras como: <b>n√£o,
para, que, e, a, etc...</b> .</p> <p>Ap√≥s a apresenta√ß√£o do tema, bem como a demonstra√ß√£o da l√≥gica, ser√£o apresentados
todos os resultados obtidos a partir dos testes feitos.</p>

# INTRODU√á√ÉO

As √°rvores desempenham um papel fundamental na programa√ß√£o, representando uma estrutura de dados essencial para
organizar e manipular informa√ß√µes de forma eficiente. Neste contexto, existem diversos tipos de √°rvores, cada uma com
suas caracter√≠sticas e aplica√ß√µes espec√≠ficas. Neste artigo, exploraremos o conceito de √°rvores na programa√ß√£o, com
foco em tr√™s tipos populares: √°rvores bin√°rias, √°rvores AVL e √°rvores de Huffman.

√Årvores bin√°rias s√£o estruturas de dados simples, compostas por n√≥s que podem ter no m√°ximo dois filhos, um √† esquerda e
outro √† direita. Elas s√£o amplamente utilizadas em aplica√ß√µes como busca bin√°ria e percorrer hierarquias de dados,
tornando-as valiosas em muitos algoritmos e sistemas.

As √°rvores AVL, por sua vez, s√£o uma varia√ß√£o das √°rvores bin√°rias que mant√™m um balanceamento autom√°tico. Isso
significa que, ao inserir ou remover elementos, a √°rvore √© reequilibrada para garantir que a diferen√ßa de altura entre
seus ramos esquerdo e direito seja limitada. Isso torna as opera√ß√µes de busca, inser√ß√£o e remo√ß√£o mais eficientes em
compara√ß√£o com √°rvores bin√°rias n√£o balanceadas.

Por fim, as √°rvores de Huffman s√£o utilizadas em compress√£o de dados. Elas s√£o projetadas para atribuir c√≥digos de
comprimento vari√°vel a s√≠mbolos de acordo com a frequ√™ncia de ocorr√™ncia de cada s√≠mbolo em um conjunto de dados. Essa
t√©cnica √© amplamente utilizada em algoritmos de compacta√ß√£o de arquivos, como o formato ZIP.

# L√ìGICA UTILIZADA

No contexto do objetivo do trabalho, o procedimento inicial envolveu abrir o arquivo com as palavras de entrada, arquivo
este chamado <i>"input.txt"</i>, que ter√° as palavras que posteriormente ser√£o removidas da tabela hash, al√©m da
abertura do arquivo de <i>stopwords</i>, o qual teria como conte√∫do, algumas das palavras que deveriam ser
desconsideradas durante o processamento do texto de entrada.

Depois, √© criada uma tabela hash contendo todas stopwords. Logo ap√≥s, o programa entra em um la√ßo de repeti√ß√£o, onde a
cada itera√ß√£o, ele l√™ uma palavra do arquivo de entrada e cria uma heap, e os 'K' primeiros elementos dessa heap s√£o
inseridos em uma arvore de cada tipo (bin√°ria, avl e huffman), lembrando que, nem a arvore e nem a heap podem conter a
palavra lida do arquivo input.txt.

Ap√≥s a cria√ß√£o das arvores, elas ser√£o impressas utilizando o m√©todo Pre-order, e ap√≥s a cria√ß√£o e impress√£o de cada
arvore, ser√° impresso na tela o tempo necess√°rio para cada uma das palavras.

‚ö†Ô∏è Palavras com caracteres estranhos, presentes em qualquer um dos textos, n√£o foram consideradas,
exemplo: <b>"--", "^", "-", " ‚Äî ", " ‚Äî", "‚Äî", "‚Äù", "‚Äú", "-‚Äù", "‚Äî‚Äî", "‚Äî"</b>.

‚ö†Ô∏è Para alterar a quantidade de arquivos de texto que o programa l√™, basta modificar o valor do literal qnt , no arquivo
main.cpp. J√° para alterar o tamanho da Heap, basta modificar o literal K, no arquivo heap.hpp.

‚ö†Ô∏è As palavras inseridas no arquivo input.txt n√£o podem ter acentos.

<h2>‚öôÔ∏è Estruturas: </h2>

As estruturas utilizadas foram as seguintes:

* unordered_map (C++);
* vector (C++).
* Arvore Bin√°ria
* Arvore AVL
* Arvore Huffman

Onde o <i>"unordered_map"</i> foi utilizado para criar as Tabelas Hash, na qual os dados s√£o armazenados ap√≥s a leitura
dos arquivos, e o <i>"vector"</i>, utilizado para conter a Heap.

O cont√™iner <i>"unordered_map"</i>, baseado em uma Tabela Hash, oferece acesso com custo O(1). No entanto, uma quest√£o a
ser considerada com tabelas hash √© que, quando muito populadas, a adi√ß√£o de novos itens pode resultar em colis√µes. Caso
colis√µes se tornem frequentes, a performance do programa pode ser afetada negativamente.

Para contornar essa situa√ß√£o, a estrutura realiza uma troca de fun√ß√µes. Essa nova fun√ß√£o, dada a entrada, calcula a
posi√ß√£o onde o item ser√° inserido na hash e, se necess√°rio, recalcula a posi√ß√£o de todos os itens existentes. Esse
procedimento √© uma opera√ß√£o mais intensiva e pode impactar consideravelmente o desempenho.

O uso do <i>"unordered_map"</i> √© vantajoso, pois √© uma estrutura j√° implementada em C++, tornando sua utiliza√ß√£o direta
e simples. Al√©m disso, a implementa√ß√£o interna do <i>"unordered_map"</i> √© otimizada, superando potencialmente tabelas
hash manuais. Isso se deve √†s otimiza√ß√µes empregadas, incluindo t√©cnicas n√£o convencionais, como deslocamentos (shifts),
que podem ser observadas, por exemplo, nas fun√ß√µes da fam√≠lia MurmurHash. Isso contribui para um desempenho eficiente e
confi√°vel.

O Heap foi constru√≠do dentro de um <i>"vector"</i> em vez de uma lista, principalmente por raz√µes de praticidade. O uso
da estrutura <i>vector</i> oferece maior flexibilidade e simplicidade em compara√ß√£o com uma lista, sendo uma escolha
mais natural para uma implementa√ß√£o que visasse simplicidade no c√≥digo e no entendimento.

A √°rvore bin√°ria √© o tipo mais simples de √°rvore, onde cada n√≥, possui dois filhos, o direito e o esquerdo, sendo que o
filho direito √© maior que o n√≥ e o filho esquerdo menor. Nesta implementa√ß√£o, n√£o √© poss√≠vel ter dois n√≥s com as mesmas
palavras. O objetivo de uma √°rvore √© tentar manter o custo de busca o mais proximo de O(log(n)) poss√≠vel,
por√©m, gra√ßas a arvore bin√°ria n√£o realizar rota√ß√µes, caso os dados n√£o estejam ordanados previamente, ela n√£o
conseguir√°
manter seu tempo de busca pr√≥ximo de O(log(n)).

J√° a √°rvore AVL √© muito parecida com a √°rvore bin√°ria, por√©m a cada inser√ß√£o, ela verifica se a √°rvore est√°
desbalanceada por meio de sua altura, caso esteja, ela utiliza de rota√ß√µes simples ou duplas, que podem ser tanto para a
direita quanto para a esquerda, que ir√£o de baixo para cima, balanceando a √°rvore. O problema, fica no custo de inser√ß√£o
onde as constantes verifica√ß√µes com rela√ß√£o ao balanceamento da √°rvore ir√£o aumentar o custo do programa. Em casos de
√°rvores muito pequenas, muitas vezes n√£o compensa utilizar a √°rvore AVL, pois ela poss√≠velente ir√° realizar v√°rias
rota√ß√µes, que deixar√° o programa mais lento do que somente ler a √°rvore de forma desbalanceada.

Por outro lado, a √°rvore Huffman √© uma estrutura de dados especializada em compress√£o de dados, projetada para reduzir o tamanho de arquivos de maneira eficiente. Ela opera de forma diferente das √°rvores bin√°rias e AVL, sendo constru√≠da com base na frequ√™ncia de ocorr√™ncia de cada caractere em um conjunto de dados. Os caracteres mais frequentes s√£o colocados em n√≠veis mais altos da √°rvore, enquanto os menos frequentes ficam em n√≠veis mais baixos. Isso permite que os caracteres mais comuns sejam representados por c√≥digos mais curtos, economizando espa√ßo de armazenamento.

O algoritmo de constru√ß√£o da √°rvore Huffman √© extremamente eficaz na compacta√ß√£o de dados, tornando-a uma escolha ideal para a compress√£o de arquivos, como imagens, textos e √°udios. No entanto, sua aplica√ß√£o √© limitada √† compress√£o e descompress√£o de dados e n√£o serve para fins de busca ou ordena√ß√£o, como as √°rvores bin√°rias e AVL. Portanto, a escolha da estrutura de dados depende das necessidades espec√≠ficas do problema a ser resolvido.

Como j√° citado anteriormente, o objetivo principal do trabalho n√£o era implementar as estrutras e sim dar resultados
mensur√°veis para entender melhor as vantagens e desvantagens de cada arvore. Por conta disso, n√£o estenderemos muito
sobre as funcionalidades de tabelas hash, nem do heap, nem de cada arvore individualmente. Portanto, para o melhor
entendimento das dos dois templates, recomendo o site CPPReference, presente nas refer√™ncias deste README.

As √°rvores AVL e bin√°ria, s√≥ seram inseridas palavras cujo sua frequ√™ncia seja diferente. Portanto, caso hajam duas
palavras armazenadas na heap, ambas com uma frequ√™ncia igual, s√≥mente a primeira ser√° inserida na √°rvore. Pois as
arvores foram implementadas de modo que o identificador de cada palavra √© sua string.

<h2>üïó Tempo: </h2>

<p>Para coletar o tempo gasto entre cada intera√ß√£o, utilizou-se a biblioteca <code>< chrono ></code>. Ap√≥s a capta√ß√£o, o tempo exibido para o usu√°rio √© apresentado 
em milisegundos.

# RESULTADOS E AN√ÅLISE

O computador no qual foi utilizado para realizar todos os testes que presentes abaixo possui as seguintes configura√ß√µes:
Processador <b>i7
11800H</b>, <b>16GB</b> de mem√≥ria principal, operando em <b> 3200MTs CL 22</b> e como Sistema Operacional foi usado
o <b>Arch Linux</b>.

Utilizando uma heap com o K = 20, e tendo como entrada o arquivo globalizacao.txt, provido pelo
pelo professor, e com o input.txt populado pela palavra realmente, conseguimos criar a seguinte tabela:


| Arquivo de Entrada | Tempo   (ms) | 
|--------------------|--------------|
| AVL                | 4.7828e-05   |
| Bin√°ria            | 6.555e-06    | 
| Huffman            | 7.3371e-05   |


Nessa fase de testes, a m√©dia aritm√©tica dos tempos obtidos foi calculada e analisada, o que permitiu avaliar de maneira
confi√°vel o desempenho do sistema em diferentes cen√°rios de tamanho de heap. Esses resultados forneceram insights
valiosos sobre a efic√°cia e a efici√™ncia do projeto como um todo.

<h2>üìà Conclus√µes: </h2>

Portanto, como o esperado, o tempo para inserir e imprimir uma √°rvore AVL foi maior que o da bin√°ria e da huffman, isso acontece
devido as rota√ß√µes que ocorrem a cada inser√ß√£o da √°rvore AVL. Neste caso, a √°rvore huffman acabou por gastar mais tempo
que a bin√°ria, pois enquanto a bin√°ria s√≥ insere, a hufftman ordena e por fim insere.
Oberserva√ß√£o: dado a forma com que as √°rvores foram implementadas, as √°rvores bin√°rias e AVL n√£o inserem palavras cujo seu value seja
igual a de outra palavra inserida anteriormente, j√° a Huffman, insere. Fazendo com que a √°rvore huffman sofra de uma leve
desvantagem.

# COMPILA√á√ÉO E EXECU√á√ÉO

O algor√≠tmo disponibilizado possui um arquivo Makefile que realiza todo o procedimento de compila√ß√£o e execu√ß√£o. Para
tanto, temos as seguintes diretrizes de execu√ß√£o:

| Comando      | Fun√ß√£o                                                                                  |                     
|--------------|-----------------------------------------------------------------------------------------|
| `make clean` | Apaga a √∫ltima compila√ß√£o realizada contida na pasta build                              |
| `make`       | Executa a compila√ß√£o do programa utilizando o gcc, e o resultado vai para a pasta build |
| `make run`   | Executa o programa da pasta build ap√≥s a realiza√ß√£o da compila√ß√£o                       |

√â v√°lido ressaltar a import√¢ncia de seguir as seguintes instru√ß√µes para garantir o bom funcionamento do programa:

1. Certifique-se de ter o arquivo de stop words na pasta ["dataset"](./dataset) com o
   nome ["stopwords.txt"](./dataset/stopwords.txt).

2. Coloque os arquivo de texto na mesma pasta, com o nome ["text0.txt"](./dataset/input0.txt).
    * Observa√ß√£o, em caso de mais de um arquivo, o segundo dever√° se chamar "input1.txt", o terceiro "input2.txt" e
      assim por diante. Tamb√©m ser√° necess√°rio mudar o tamanho da constante qnt, definido na main.

3. Insira o arquivo com as palavras de entrada na pasta ["dataset"](./dataset) com o
   nome ["input.txt"](./dataset/stopwords.txt).

Seguindo essas orienta√ß√µes, o programa ser√° capaz de executar corretamente e imprimir o resultado no terminal.

# BIBLIOTECAS

Para o funcionamento desejado, fora utilizadas as seguintes bibliotecas:<br/>

<ul>
	<li><code>#include 'iostream'  </code></li>
	<li><code>#include 'fstream'</code></li>
	<li><code>#include 'chrono'</code></li>
	<li><code>#include 'string'</code></li>
	<li><code>#include 'vector'</code></li>
	<li><code>#include 'unordered_map'</code></li>
</ul>

<hr/>

# REFER√äNCIAS

<ul>
   <li>https://cplusplus.com/reference/iostream/</li>
    <li>https://cplusplus.com/reference/fstream/</li>
    <li>https://cplusplus.com/reference/chrono/</li>
    <li>https://cplusplus.com/reference/string/</li>
    <li>https://cplusplus.com/reference/vector/vector/</li>
    <li>https://cplusplus.com/reference/unordered_map/unordered_map/</li>
	<li><b>ROSEN, Kenneth</b>. Matem√°tica Discreta e Suas Aplica√ß√µes 6¬™ Ed. internet: https://www.mheducation.com/. 2009.</li>
	<li><b>CORMEN, Thomas</b>. Algoritmos - Teoria e Pr√°tica 3¬∫ Ed. internet: https://www.elsevier.com/pt-br, 2012.</li>
</ul>

</div>

# AUTOR

Criado por <b>C√©sar Henrique Resende Soares</b>;

Agradecimento especial a <b>Henrique Souza Fagundes</b> e ao <b>Daniel Alves Sanches</b>, ambos monitores da disciplina
de AEDS II pela ajuda durante o desenvolvimento do trabalho.

Aluno do <b>4</b>¬∞ periodo do curso de `Engenharia da Computa√ß√£o` no [CEFET-MG](https://www.cefetmg.br)
