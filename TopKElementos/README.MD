# README: Trabalho de Aquecimento

# OBJETIVOS

<div align="justify">

<p>Foi proposto pelo Prof. Me. <b>Michel Pires da Silva</b> na disciplina de <b>Algoritmos e Estrutura de Dados II</b>, um trabalho no qual o objetivo era <b>criar um <i>heap</i> com os </b><i>'K'</i><b> elementos que mais se repetiam durante o texto de entrada inserido pelo usu√°rio.</b></p>

<p>Sendo assim, ap√≥s a conclus√£o do projeto, temos aqui um algor√≠tmo capaz de ler 'n' arquivos de texto como entrada e como sa√≠da, retornar para o usu√°rio, um heap que cont√©m os <i>'K'</i> mais repetidos elementos encontrados durante a an√°lise de cada um dos textos.</br></br>
<b>- [‚úîÔ∏è] Ler v√°rios arquivos de entrada;</br></b>
<b>- [‚úîÔ∏è] Salvar o conte√∫do de cada um deles em uma Tabela Hash;</br></b>
<b>- [‚úîÔ∏è] Remover as Stopwords;</br></b>
<b>- [‚úîÔ∏è] Criar um Heap com as K palavras que mais apareceram; </br></b>
</p>

<p>Vale informar aos que n√£o conhecem, que as estruturas: <i>unordered_Map</i> e <i>vector</i> s√£o pr√≥prias da linguagem C++, portanto, caso haja alguma d√∫vida quanto ao seu funcionamento, no site <i>CPlusPlus</i> √© poss√≠vel encontrar todas informa√ß√µes sobre estrutura, contexto, implementa√ß√£o e fun√ß√µes associadas de ambos. Tamb√©m √© v√°lido introduzir o termo "<i>stopwords"</i> que nada mais s√£o que palavras que devem ser desconsideradas durante a an√°lise do texto, pois impactariam diretamente no resultado durante a contagem de repeti√ß√µes. Estas, s√£o palavras como: <b>n√£o, para, que, e, a, etc...</b> .</p>
<p>Ap√≥s a apresenta√ß√£o do tema, bem como a demonstra√ß√£o da l√≥gica, ser√£o apresentados todos os resultados obtidos a partir dos testes feitos.</p>

# INTRODU√á√ÉO

<p>Nascido em Nova York, Robert W. Floyd (1936 - 2001) com 17 anos, concluiu o curso de bacharelado em artes liberais na Universidade de Chicago e em 1958 recebeu o t√≠tulo de Bacharel em f√≠sica. A partir da d√©cada de 60, iniciou uma longa jornada de publica√ß√µes de muitos trabalhos not√°veis, dentre esses, o desenvolvimento do algoritmo de ordena√ß√£o <i>HeapSort</i>.</p>

<p><b>O que √© um heap em programa√ß√£o?</b> Heap √© uma estrutura de dados que organiza seus elementos de acordo com prioridades, onde existe um elemento que possui a maior (ou menor) prioridade no topo do heap, e existem elementos subordinados a ele, que s√£o chamados de n√≥s filhos. Cada n√≥ filho pode conter zero, um ou mais de um n√≥ filho. Os n√≥s filhos que n√£o possuem outros n√≥s filhos s√£o chamados de folhas.</p>
<b>Caracter√≠sticas de um Heap</b>
<ul>
<li>Topo: Todo heap possui o elemento de maior (ou menor) prioridade no topo;</li>
<li>Ordem de Prioridade: Os elementos em um heap seguem uma ordem de prioridade espec√≠fica, como um "max-heap" onde os pais t√™m prioridade sobre os filhos, ou um "min-heap" onde os pais t√™m menor prioridade;</li>
<li>Estrutura de Filhos: Cada n√≥ pai pode ter zero, um ou mais filhos;</li>
<li>N√≠vel (ou profundidade): √© chamada a dist√¢ncia de um n√≥ at√© o topo;</li>
<li>Altura: O n√∫mero m√°ximo de n√≠veis entre o topo do heap e qualquer uma de suas folhas;</li>
<li>Folha: Um n√≥ que n√£o possui filhos.</li>
</ul>

Para um melhor entendimendo da representa√ß√£o de um Heap, a figura abaixo mostra mais de uma forma de representar um <i>
Heap</i> que cont√©m os seguintes n√∫meros: {100, 19, 36, 17, 3, 25, 1, 2, 7}

![imagem](img/Max-Heap-new.svg.png)

A figura acima, primeiro mostra um <i>Heap</i> representado em forma de √°rvore e, abaixo, o mesmo <i>Heap</i>,
entretanto, representado como um vetor. Sendo assim, depois de ser ordenado por um "max-heap", o maior elemento da <i>
Heap</i> fica na primeira posi√ß√£o do vetor. O filho esquerdo do n√≥ que est√° na posi√ß√£o 'i', pode ser encontrado na
posi√ß√£o <code>'i + i'</code>, j√° o filho direito, estar√° na posi√ß√£o <code>'i + i + 1'</code>.

# L√ìGICA UTILIZADA

No contexto do objetivo do trabalho, o procedimento inicial envolveu a leitura de um arquivo de <i>stopwords</i>, o qual
teria como conte√∫do, todas aquelas palavras que deveriam ser desconsideradas durante o processamento do texto de
entrada. Essas palavras foram identificadas e inseridas em uma <i>Hash</i>.Logo ap√≥s, os arquivos de entrada s√£o lidos,
e caso alguma palavra fosse identificada tamb√©m na Tabela Hash das <i>stopwords</i>, ela seria gravada em outra Tabela
Hash.
Depois desse processo, cada elemento dessa tabela foi inserido individualmente em um heap. A medida que ocorria a
inser√ß√£o no heap, sua estrutura era automaticamente ajustada para perpetuar a palavra de maior frequ√™ncia na posi√ß√£o
de destaque (√≠ndice 0) do vetor. Ao t√©rmino desse processo, o vetor resultante √© apresentado ao usu√°rio por meio do
terminal da seguinte forma: <code>Posi√ß√£o 'int' Palavra: 'string' - Frequ√™ncia: 'int'</code>.<br/>
‚ö†Ô∏è Palavras com caracteres estranhos n√£o foram consideradas,
exemplo: <b>"--", "^", "-", " ‚Äî ", " ‚Äî", "‚Äî", "‚Äù", "‚Äú", "-‚Äù", "‚Äî‚Äî", "‚Äî"</b>.

<h2>‚öôÔ∏è Estruturas: </h2>

As estruturas utilizadas foram as seguintes:

* unordered_map (C++);
* vector (C++).

Onde o <i>"unordered_map"</i> foi utilizado para criar a Tabela Hash, na qual os dados s√£o armazenados ap√≥s a leitura do
arquivo, e o <i>"vector"</i>, utilizado para conter a Heap.

O cont√™iner <i>"unordered_map"</i>, baseado em uma Tabela Hash, oferece acesso com custo O(1). No entanto, uma quest√£o a
ser considerada com tabelas hash √© que, quando muito populadas, a adi√ß√£o de novos itens pode resultar em colis√µes. Caso
colis√µes se tornem frequentes, a performance do programa pode ser afetada negativamente.

Para contornar essa situa√ß√£o, a estrutura realiza uma troca de fun√ß√µes. Essa nova fun√ß√£o, dada a entrada, calcula a
posi√ß√£o onde o item ser√° inserido na hash e, se necess√°rio, recalcula a posi√ß√£o de todos os itens existentes. Esse
procedimento √© uma opera√ß√£o mais intensiva e pode impactar consideravelmente o desempenho.

O uso do <i>"unordered_map"</i> √© vantajoso, pois √© uma estrutura j√° implementada em C++, tornando sua utiliza√ß√£o direta
e simples. Al√©m disso, a implementa√ß√£o interna do <i>"unordered_map"</i> √© otimizada, superando potencialmente tabelas
hash manuais. Isso se deve √†s otimiza√ß√µes empregadas, incluindo t√©cnicas n√£o convencionais, como deslocamentos (shifts),
que podem ser observadas, por exemplo, nas fun√ß√µes da fam√≠lia MurmurHash. Isso contribui para um desempenho eficiente e
confi√°vel.

O Heap foi constru√≠do dentro de um <i>"vector"</i> em vez de uma lista, principalmente por raz√µes de praticidade. O uso
da estrutura <i>vector</i> oferece maior flexibilidade e simplicidade em compara√ß√£o com uma lista, sendo uma escolha
mais natural para uma implementa√ß√£o que visasse simplicidade no c√≥digo e no entendimento.

Como j√° citado anteriormente, o objetivo principal do trabalho n√£o era implementar as estrutras e sim resolver o
problema dos 'K' primeiros elementos. Por conta disso, n√£o estenderemos muito sobre as funcionalidades de tabelas hash,
nem do heap utilizado. Portanto, para o melhor entendimento das dos dois templates, recomendo o site CPPReference, presente
nas refer√™ncias deste README.

<h2>üïó Tempo: </h2>

<p>Para coletar o tempo gasto entre cada intera√ß√£o, utilizou-se a biblioteca <code>< chrono ></code>. Ap√≥s a capta√ß√£o, o tempo exibido para o usu√°rio √© apresentado 
em milisegundos.

# RESULTADOS E AN√ÅLISE

O computador no qual foi utilizado para realizar todos os testes que presentes abaixo possui as seguintes configura√ß√µes:
Processador <b>i7
11800H</b>, <b>16GB</b> de mem√≥ria principal, operando em <b> 3200MTs CL 22</b> e como Sistema Operacional foi usado
o <b>PopOS 22.04 LTS</b>.

Ap√≥s a conclus√£o do projeto, uma etapa crucial consistiu na realiza√ß√£o de uma s√©rie de testes. Mais precisamente, foram
conduzidos cinco testes para cada dimens√£o de heap: 5, 10, 15 e 20. Durante cada teste, mediu-se o tempo gasto desde o
in√≠cio da leitura do arquivo de entrada at√© o momento da impress√£o da heap resultante. os resultados obtidos tiveram
como arquivo de entrada o livro "Dom Casmurro" e o arquivo "Semana Machado Assis", ambos cedidos pelo professor. As
<i>stopwords</i>, tamb√©m foram definidas pelo professor em sala de aula.

Nessa fase de testes, a m√©dia aritm√©tica dos tempos obtidos foi calculada e analisada, o que permitiu avaliar de maneira
confi√°vel o desempenho do sistema em diferentes cen√°rios de tamanho de heap. Esses resultados forneceram insights
valiosos sobre a efic√°cia e a efici√™ncia do projeto como um todo.

| Tamanho da Heap Impressa | Arquivo de Entrada   | Tempo   (ms) | 
|--------------------------|----------------------|--------------|
| <i>"5"</i>               | Dom Casmurro         | 0.0668521    |
| <i>"10"</i>              | Dom Casmurro         | 0.0673466    | 
| <i>"15"</i>              | Dom Casmurro         | 0.0666766    |
| <i>"20"</i>              | Dom Casmurro         | 0.0698978    |
| <i>"5"</i>               | Semana Machado Assis | 0.297294     |
| <i>"10"</i>              | Semana Machado Assis | 0.303094     | 
| <i>"15"</i>              | Semana Machado Assis | 0.293005     |
| <i>"20"</i>              | Semana Machado Assis | 0.29918      |

Dado a tabela acima, √© poss√≠vel observar que o tamanho da Heap impressa n√£o impactou praticamente em nada no tempo de
execu√ß√£o do programa. Isso aconteceu gra√ßas a forma com que o algor√≠tmo foi implementado, onde cada palavra armazenada
na
tabela Hash era movida para a Heap, o que significa que, a cada intera√ß√£o, a estrutura da Heap era reorganizada em tempo
de execu√ß√£o.

<h2>üìà Conclus√µes: </h2>

Embora existam alternativas que possam potencialmente reduzir os custos computacionais da implementa√ß√£o, este trabalho
atingiu seus objetivos de maneira simples e compreens√≠vel. Algumas estruturas poderiam ter sido manualmente
implementadas ou substitu√≠das, como √© o caso do uso do vector para armazenar a heap, que poderia ser trocado por uma
list.

No entanto, com base nos resultados obtidos, foi poss√≠vel concluir que √© evidente que o fator que exerce maior impacto
na velocidade do programa √© o tamanho dos arquivos de entrada. Conforme a intui√ß√£o prev√™, o tempo de execu√ß√£o aumenta √†
medida que o tamanho de palavras presentes nos arquivos cresce.

# COMPILA√á√ÉO E EXECU√á√ÉO

O algor√≠tmo disponibilizado possui um arquivo Makefile que realiza todo o procedimento de compila√ß√£o e execu√ß√£o. Para
tanto, temos as seguintes diretrizes de execu√ß√£o:

| Comando      | Fun√ß√£o                                                                                  |                     
|--------------|-----------------------------------------------------------------------------------------|
| `make clean` | Apaga a √∫ltima compila√ß√£o realizada contida na pasta build                              |
| `make`       | Executa a compila√ß√£o do programa utilizando o gcc, e o resultado vai para a pasta build |
| `make run`   | Executa o programa da pasta build ap√≥s a realiza√ß√£o da compila√ß√£o                       |

√â v√°lido ressaltar a import√¢ncia de seguir as seguintes instru√ß√µes para garantir o bom funcionamento do programa:

1. Certifique-se de ter o arquivo de stop words na pasta ["dataset"](./dataset) com o
   nome ["stopwords.txt"](./dataset/stopwords.txt).

2. Coloque os arquivo de entrada na mesma pasta, com o nome ["input0.txt"](./dataset/input0.txt).
    * Observa√ß√£o, em caso de mais de um arquivo, o segundo dever√° se chamar "input1.txt", o terceiro "input2.txt" e
      assim por diante. Tamb√©m ser√° necess√°rio mudar o tamanho da constante qnt, definido na main.

Seguindo essas orienta√ß√µes, o programa ser√° capaz de executar corretamente e imprimir o resultado no terminal.

# BIBLIOTECAS

Para o funcionamento desejado, fora utilizadas as seguintes bibliotecas:<br/>

<ul>
	<li><code>#include 'iostream'  </code></li>
	<li><code>#include 'fstream'</code></li>
	<li><code>#include 'chrono'</code></li>
	<li><code>#include 'string'</code></li>
	<li><code>#include 'vector'</code></li>
	<li><code>#include 'unordered_map'</code></li>
</ul>

<hr/>

# REFER√äNCIAS

<ul>
   <li>https://cplusplus.com/reference/iostream/</li>
    <li>https://cplusplus.com/reference/fstream/</li>
    <li>https://cplusplus.com/reference/chrono/</li>
    <li>https://cplusplus.com/reference/string/</li>
    <li>https://cplusplus.com/reference/vector/vector/</li>
    <li>https://cplusplus.com/reference/unordered_map/unordered_map/</li>
	<li><b>ROSEN, Kenneth</b>. Matem√°tica Discreta e Suas Aplica√ß√µes 6¬™ Ed. internet: https://www.mheducation.com/. 2009.</li>
	<li><b>CORMEN, Thomas</b>. Algoritmos - Teoria e Pr√°tica 3¬∫ Ed. internet: https://www.elsevier.com/pt-br, 2012.</li>
</ul>

</div>

# AUTOR

Criado por <b>C√©sar Henrique Resende Soares</b>;

Agradecimento especial a <b>Henrique Souza Fagundes</b> e ao <b>Daniel Alves Sanches</b>, ambos monitores da disciplina de AEDS II pela ajuda durante o desenvolvimento do trabalho.

Aluno do <b>4</b>¬∞ periodo do curso de `Engenharia da Computa√ß√£o` no [CEFET-MG](https://www.cefetmg.br)
